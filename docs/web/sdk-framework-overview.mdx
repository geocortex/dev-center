---
title: Framework Overview
description: Geocortex Web - Learn about Components and Services
---

import UseCaseCard from "../../src/components/UseCaseCard";
import UseCaseContainer from "../../src/components/UseCaseContainer";

The Geocortex Web SDK Framework allows you to extend the functionality of a Geocortex Web application with custom development. There are three main extension points in the framework:

#### Components

Components power the UI experience of Geocortex Web. Components are composed of a React Component and a backing data model. Layout files are composed of a nested hierarchy of components which are instantiated at runtime.

#### Services

Services provide the shared infrastructure and core logic that power app behavior. Services do not have an associated UI, and there is only one instance of a service per application.

#### Commands and Operations

Commands and operations provide a framework for executing app wide behavior. Services and components can both run and implement commands and operations, allowing for interaction and consistent behavior without tight coupling.

<!-- TODO-API links to components -->

In general, these three elements interact to form a Geocortex Web Application.

-   Services are used to implement app wide behavior, such as theming or authentication, and then expose that logic through commands and operations, such as `ui.set-theme` (implemented by the `BrandingService`) or `auth.sign` (implemented by the `AuthenticationService`).
-   Components run commands and operations to interact with global concerns, but can also implement a command or operation if they are responsible for a global concern, or need to facilitate interaction with another component or service.
-   Component and service interaction through commands and operations is preferred, but components and services can also be tightly coupled to each other through [model injection](TODO-model-injection-link) or [service injection](TODO-service-injection-link)

## Framework Entry Point

The Geocortex Web SDK framework compiles custom components, services, and commands and operations into a library. The library is defined by the registration function exported from `src/index.ts`.

```ts title="src/index.ts"
export default function (registry: LibraryRegistry) {
    registry.registerService({
        id: "custom-service",
        getServiceType: () => CustomService,
    });
    registry.registerComponent({
        name: "custom-component",
        namespace: "your.custom.namespace",
        getComponentType: () => CustomComponent as ComponentType,
        itemType: "custom-component-model",
        title: "Custom Component",
    });
    registry.registerModel({
        getModelType: () => CustomComponentModel,
        itemType: "custom-component-model",
    });
    registry.registerCommand("my.custom-command", {
        serviceId: "custom-service",
        executeMethodName: "_doSomething",
    });
    registry.registerOperation("my.custom-operation", {
        serviceId: "custom-service",
        executeMethodName: "_doAnotherThing",
    });
}
```
