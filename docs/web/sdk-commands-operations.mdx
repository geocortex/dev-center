---
title: Commands and Operations
---

import FollowAlongSnippet from "./snippets/follow-along.mdx";
import useBaseUrl from "@docusaurus/useBaseUrl";
import Tabs from "@theme/Tabs";
import TabItem from "@theme/TabItem";
import UseCaseCard from "../../src/components/UseCaseCard";
import UseCaseContainer from "../../src/components/UseCaseContainer";

Commands and operations play a large role in the infrastructure and behavior of Geocortex Web. They also are a powerful core part of the Geocortex Web SDK, as they enable easily configurable behavior. [Existing commands and operations](api-commands-operations-events.mdx) combined with [workflow](usecases-run-workflow-app-config.mdx) can enable powerful custom behavior without custom code. Commands and operations can be used through the app config to customize built in components, or they can be executed in custom components and services.

## Key Concepts

-   Commands and operations act as global functions which can be executed from any component or service.
-   Built in components have properties in the app config which take an command or operation as values, allowing their internal a behavior to be configured.
-   Commands run behavior but do not produce output, while operations run behavior and produce an output.
-   Commands and operations can be run sequentially in what's called a "command chain" to enable complex actions.

## Command and Operations in App Config

<FollowAlongSnippet />

Commands and operations for built in components are configurable in the app config JSON.

```json
{
    "schemaVersion": "1.0",
    "items": [
        ...
        {
            "id": "button-config",
            "iconId": "zoom-in",
            "title": "Zoom In",
            // highlight-next-line
            "action": "map.zoom-in",
            "$type": "menu-item"
        }
        ...
    ]
}
```

App config properties like `action` can accept a singular command/operation or a **command chain** .

:::note
Command chains are arrays of commands and operations which are executed sequentially. The output of previous operations is passed along the chain to future operations and commands, allowing for complex input dependent behavior.
:::

```json
{
    "id": "zoom",
    "$type": "menu-item",
    "title": "Zoom to Features",
    // highlight-next-line
    "action": ["map.zoom-to-features", "highlights.pulse"]
}
```

### Passing Explicit Arguments

Commands and operations can be configured with an `arguments` property that passes values to the function at execution time.

:::tip
You can find out what arguments a command or operation takes in the [commands and operations API reference](api-commands-operations-events.mdx).
:::

```json
{
    "$type": "menu",
    "id": "iwtm",
    "items": [
        {
            "title": "Hello",
            "isEnabled": true,
            "iconId": "info",
            "action": {
                "name": "ui.display-notification",
                // highlight-start
                "arguments": {
                    "message": "World"
                }
                // highlight-end
            }
        }
    ]
}
```

### Passing Implicit Arguments

If you do not pass explicit arguments, then implicit arguments will be passed to the command or operation. Implicit arguments come from the [context](https://docs.geocortex.com/webviewer/latest/admin-help/Default.htm#gwv/add-a-workflow-to-an-app.htm#use-the-menu-context-as-a-workflow-input) that a command or operation is running in, or from a previous operation in the command chain

For example, let's look at the configuration for the `featureActions` and `onFeatureClick` properties of a `<results-list>` component model.

```json
{
    "schemaVersion": "1.0",
    "items": [
        ...
        {
            "id": "results-list",
            "$type": "results",
            "featureActions": [
                "item://menu-item/zoom",
                "item://menu-item/save-features-to-csv"
            ],
            // highlight-next-line
            "onFeatureClick": "results.display-details"
        },
        {
            "id": "zoom",
            "$type": "menu-item",
            "title": "Zoom to Features",
            // highlight-next-line
            "action": ["map.zoom-to-features", "highlights.pulse"]
        },
        {
            "id": "save-features-to-csv",
            "$type": "menu-item",
            "title": "Save Features to CSV",
            // highlight-next-line
            "action": ["results.convert-to-csv", "system.download-file"]
        },
        ...
    ]
}
```

Since these commands and operations are running from the [context](https://docs.geocortex.com/webviewer/latest/admin-help/Default.htm#gwv/add-a-workflow-to-an-app.htm#use-the-menu-context-as-a-workflow-input) of a `<results-list>` component, the first command or operation will receive the relevant feature as its input. If the property is a command chain, the next step in line will receive one of two possible inputs.

1. If the previous step was a command (which doesn't produce output), then the original input is passed on to the next step.
2. If the previous step was an operation (which produces an output), then the output of that operation is passed onto the next step.

In this way, you can run multiple commands in a row that receive a feature as input, as seen in the `action` command chain of `zoom-feature` in the example.

```json
// Both of these commands will receive the Features argument passed into the command chain
["map.zoom-to-features", "highlights.pulse"]
```

The `action` command chain of `save-features-to-csv` demonstrates how an operation can pass its output to the next command or operation in the list. In this case, it's passing the csv content to `system.download-file`.

```json
// `system.download-file` will receive the output of `results.convert-to-csv`
["results.convert-to-csv", "system.download-file"]
```

### Example: Configured Map and I Want to Menu

This example demonstrates two different types of argument passing behavior.

<Tabs
  defaultValue="app"
  values={[
    { label: 'App Config', value: 'app', },
    { label: 'Layout', value: 'layout', },
  ]
}>
<TabItem value="app">

```json title="app/app.json"
{
    "schemaVersion": "1.0",
    "items": [
        {
            "$type": "map-extension",
            "id": "default",
            "webMap": "https://www.arcgis.com/home/item.html?id=0ba877a4185448cb832af9a661031e31",
            "onClick": [
                "tasks.identify",
                "highlights.add-focus",
                "results.display"
            ]
        },
        {
            "$type": "menu",
            "id": "iwtm",
            "items": [
                {
                    "title": "Return to Default Map View",
                    "isEnabled": true,
                    "action": [
                        {
                            "name": "map.zoom-to-initial-viewpoint",
                            "arguments": ["item://map-extension/default"]
                        }
                    ]
                }
            ]
        }
    ]
}
```

</TabItem>
<TabItem value="layout">

```xml title="app/layout.xml"
<?xml version="1.0" encoding="utf-8" ?>
<layout xmlns="https://geocortex.com/layout/v1">
    <split resizable="true">
        <panel show-close-button="false" width="26">
            <results-list active="true"/>
            <feature-details active="false"/>
        </panel>
        <map config="default">
            <iwtm config="iwtm" slot="top-left"/>
        </map>
    </split>
</layout>
```

</TabItem>
</Tabs>

Let's first look at the command chain defined on the `onClick` property of a map. This chain consists of three operations and commands:

-   `task.identify`,
-   `highlights.add-focus`
-   `results.display`

`tasks.identify` does not have any named arguments defined, so it will take arguments passed into it from its current [context](https://docs.geocortex.com/webviewer/latest/admin-help/Default.htm#gwv/add-a-workflow-to-an-app.htm#use-the-menu-context-as-a-workflow-input). Since this chain is run on a map click, the context argument passed in has the shape:

```json
{
  "geometry": "Esri.Point(<map-click-location>)",
  ... <other props>
}
```

<!-- TODO-API tasks.identify operation direct link -->

`tasks.identify` receives this argument, and since it is an operation, produces an output. Looking at the [Commands and Operations Documentation](api-commands-operations.mdx), `tasks.identify` has output of type `Features`.

`highlights.add-focus` and `results.display` both take a `Features` type input, so the output of `tasks.identify` will work nicely. `highlights.add-focus` is immediately after `tasks.identify`, so it receives the output of identify. Since `highlights.add-focus` is a command, it does not produce any output. `results.display` will receive the output of the last operation, `tasks.identify`. In this way, you can pass the output of an operation to multiple commands.

<!-- TODO-API MapExtensionArgs direct link -->

The second behavior in this application is a `map.zoom-to-initial-viewpoint` command on the I Want To Menu. This command takes `Maps` type argument. The `argument` property in the app config supplies an array of maps by referencing the `default` map with an [**Item Uri**](concepts-advanced-config.mdx#item-uris). Item URIs are a way of referencing other items within the app config.

## Using Commands and Operations in Custom Components and Services

The [built-in commands and operations](api-commands-operations-events.mdx), as well as custom commands and operations, can be used from any custom component or service.

<UseCaseContainer>
    <UseCaseCard
        title="Run Commands or Operations from a Custom Service"
        description="Learn how to run a command or operation from a custom service"
        link="sdk-services-commands-operations#running-custom-commands"
    />
    <UseCaseCard
        title="Run Commands or Operations from a Custom Component"
        description="Learn how to run a command or operation from a custom component"
        link="sdk-components-commands-operations#running-custom-commands"
    />
</UseCaseContainer>

## Custom Commands and Operations

[Components or Services](concepts-components-services.mdx) are usually responsible for registering a command or operation implementation with Geocortex Web. Once a command or operation has been registered, it can be used from anywhere in the application. [Custom Commands and Operations](usecases-implement-command-operation.mdx) are registered with custom services or custom components in this manner.

## Next Steps

<UseCaseContainer>
    <UseCaseCard
        title="Implement a Custom Command or Operation from a Custom Service"
        description="Learn how to implement a command or operation from a custom service"
        link="sdk-services-commands-operations#implementing-commands-and-operations"
    />
    <UseCaseCard
        title="Implement a Custom Command or Operation from a Custom Component"
        description="Learn how to implement a command or operation from a custom component"
        link="sdk-components-commands-operations#implementing-commands-and-operations"
    />
</UseCaseContainer>
