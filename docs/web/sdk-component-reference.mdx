---
title: Component Reference
---

The following is an example of a custom component that has been created using the Geocortex Web SDK. In general, Geocortex Web components are functional React components extended with a few new behaviors and patterns.

```tsx
import React, { useState } from "react";
import {
    LayoutElement,
    LayoutElementProperties,
} from "@geocortex/web/components";
import List from "@geocortex/web/ui/list";
import ListItem from "@geocortex/web/ui/list-item";
import TitleBar from "@geocortex/web/ui/title-bar";
import Button from "@geocortex/web/ui/button";
import { useWatchAndRerender } from "@geocortex/web/ui/hooks";
import DialogActions from "@geocortex/web/ui/dialog-actions";
import ExampleComponentModel from "./ExampleComponentModel";

export default function ExampleComponent(
    props: LayoutElementProperties<ExampleComponentModel>
) {
    const { model } = props;
    const [hidden, setHidden] = useState(false);

    useWatchAndRerender(model, "items");

    var x = model.items.map((item, idx) => (
        <ListItem key={idx} title={item}></ListItem>
    ));

    return (
        <LayoutElement {...props}>
            <List>
                <DialogActions key="dialog-actions">
                    <TitleBar text="Some Title"></TitleBar>
                    {hidden && (
                        <Button onClick={() => setHidden(false)}>
                            Show Component
                        </Button>
                    )}
                    {!hidden && (
                        <Button onClick={() => setHidden(true)}>
                            Hide Component
                        </Button>
                    )}
                </DialogActions>
                {!hidden &&
                    model.items
                        .map((item, idx) => (
                            <ListItem key={idx}>{item}</ListItem>
                        ))
                        .toArray()}
            </List>
        </LayoutElement>
    );
}
```

## Component Registration

All components need to be registered with the Geocortex Web API in order to be used in a layout.

```ts
export default function (registry: LibraryRegistry) {
    // ... other item registrations

    registry.registerComponent({
        // The name used to identify the component in the layout
        name: "example",
        // The namespace used to identify the component in the layout, e.g. <custom:example/>
        namespace: LAYOUT_NAMESPACE,
        // The class corresponding to the React Functional Component
        getComponentType: () => ExampleComponent as ComponentType,
        // The model type this component is bound to.
        itemType: "example-model",
        title: "Example Component",
    });
```

Once registered in this manner, a component can be used in a layout by referring it by name and [namespace](TODO-namespace-api-layout-link).

```xml
<?xml version="1.0" encoding="UTF-8"?>
<layout xmlns="https://geocortex.com/layout/v1" xmlns:custom="custom.abc123">
    <custom:example/>
</layout>
```

## Component Anatomy

<!-- TODO - link to react docs -->

At it's core, each custom component is a react component that takes in props and renders a DOM element. However, custom components can implement a couple patterns which are specific to Geocortex Web.

### Rendering

Geocortex Web custom components return a DOM element, like any other react component, but with one restriction. The root DOM element must be a `<LayoutElement/>` node with all the layout attributes passed as props.

```tsx
export default function ExampleComponent(
    props: LayoutElementProperties<ExampleComponentModel>
) {
    // highlight-next-line
    return <LayoutElement {...props}></LayoutElement>;
}
```

### Props

Custom components take in a special type of props, `LayoutElementProperties`. These props include the React props but also include props specific to the Framework, such as;

-   The model associated with the component,
-   The id of the component in the layout
-   The width and height, along with other [presentation attributes](TODO-link-presentation-attributes) in the layout

The `LayoutElementProperties` interface takes in `ComponentModelBase` type class corresponding to the model associated with the component. This will give the `props.model` property the correct type.

```tsx
export default function ExampleComponent(
    props: LayoutElementProperties<ExampleComponentModel>
) {
    // highlight-next-line
    const { model, id, width, height, slot, stretch } = props;
    ...
}
```

### State

Geocortex Web uses two patterns to manage state in a component. First, any purely local UI or presentation logic state should be captured using the [React state hook](https://reactjs.org/docs/hooks-state.html) pattern. For data that comes from configuration or other sources, like a service, the components model should be treated as the state.

```tsx
export default function ExampleComponent(
    props: LayoutElementProperties<ExampleComponentModel>
) {
    // highlight-next-line
    const [hidden, setHidden] = useState(false);
    ...
}
```

### Models

Every component is bound to specific [**item type**](TODO-item-type-link), and each item type is bound to a specific model.
In this snippet, the `ExampleComponent` is bound to the `example-model` item type. The `ExampleComponentModel` is registered as the `example-model` item type, meaning that an `ExampleComponentModel` will be injected into the props of each `ExampleComponent`.

```ts
export default function (registry: LibraryRegistry) {
    // ... other item registrations

    registry.registerComponent({
        name: "example",
        namespace: LAYOUT_NAMESPACE,
        getComponentType: () => ExampleComponent as ComponentType,
        // highlight-next-line
        itemType: "example-model",
        title: "Example Component",
    });
    registry.registerModel({
        getModelType: () => ExampleComponentModel,
        // highlight-next-line
        itemType: "example-model",
    });
}
```

It's best practice to use the model to define configurable or persistent state, and use the [component hooks](TODO-link-component-hooks) to interact with the model. For UI specific transient state, like an active selection, it is recommended you use the [React state hooks](https://reactjs.org/docs/hooks-state.html).

For example, the following component delegates the management of the list item content to it's model. The component does not have to concern itself with whether those list items come from config, dynamic application events, or other sources.

:::tip
This example uses the `useWatchAndRerender` [component hook](sdk-component-hooks.mdx) in order to dynamically update the component when the model changes.
:::

```tsx
export default function ExampleComponent(
    props: LayoutElementProperties<ExampleComponentModel>
) {
    const { model } = props;

    useWatchAndRerender(model, "items");

    return (
        <LayoutElement {...props}>
            <List>
                {model.items
                    .map((item, idx) => <ListItem key={idx}>{item}</ListItem>)
                    .toArray()}
            </List>
        </LayoutElement>
    );
}
```

## Models and Configuration

Geocortex Web provides a suite of flexible, highly configurable components, and this flexibility is powered in a large part by the relationship between [app config](concepts-app-config.mdx), models, and components. Each model has the potential to consume static app config, which it can deserialize and transform before providing the data to it's associated component for rendering.

The following model defines a simple configurable property `items`.

-   The shape of this property in the app config JSON file is defined by the `items` property in the `ExampleComponentModelProperties` interface.
-   The shape of this property in the model is defined by the `items` property in the `ExampleComponentModel` class.

:::tip
Marking properties in the `ComponentModelProperties` interface as optional allows them to be left out of config and populated with default values. It's best practice to make properties optional and provide a default value if possible.
:::

The `ExampleComponentModel` class consumes the configuration by extending the `ComponentModelBase<ExampleComponentProperties>` interface, using the `@serializable` class decorator and then defining serialization logic in an override of the `_getSerializableProperties()` method.

The `_getSerializableProperties()` method has a few purposes.

1. Provide serialization logic from an model property to an object that can be serialized in a JSON file.
2. Provide deserialization logic from a JSON object to a model property.
3. Provide a default value for the JSON object if one is not given in the app config.

:::important
It's key that the existing properties also get serialized through a call to `super._getSerializableProperties()`.
:::

```ts
interface ExampleComponentModelProperties extends ComponentModelProperties {
    items?: string[];
}

// highlight-next-line
@serializable
export default class ExampleComponentModel extends ComponentModelBase<
    ExampleComponentModelProperties
> {
    items: Collection<string> = new Collection<string>();

    protected _getSerializableProperties(): PropertyDefs<
        ExampleComponentModelProperties
    > {
        // highlight-next-line
        const props = super._getSerializableProperties();
        return {
            ...props,
            items: {
                serializeModes: ["initial"],
                default: ["Default Value"],
                serialize: () => this.items.toArray(),
                deserialize: (items) => {
                    this.items.removeAll();
                    this.items.addMany(items);
                },
            },
        };
    }
}
```

Simpler properties such as `boolean` values or `string` values can have their serialization logic omitted.

```ts
interface ExampleComponentModelProperties extends ComponentModelProperties {
    stringVal?: string;
}

@serializable
export default class ExampleComponentModel extends ComponentModelBase<
    ExampleComponentModelProperties
> {
    stringVal: string;

    protected _getSerializableProperties(): PropertyDefs<
        ExampleComponentModelProperties
    > {
        const props = super._getSerializableProperties();
        return {
            ...props,
            stringVal: {
                serializeModes: ["initial"],
                default: "Simple String Value",
            },
        };
    }
}
```

## Component Lifecycle

When a Geocortex Web Application boots up, the set of components which are initially active in the layout are created and initialized. [Components like the `Panel`](TODO-panel-link) will only activate it's first child. All other components will only be created when they are activated in the layout.

:::tip
The `UIService` contains methods like `getActiveChildComponentIds()` which can be used to examine and manage the active state of components and their children.
:::

### Activation and Deactivation

Custom code can listen and react to a components activation or deactivation by subscribing to the `ui.activated` or `ui.deactivated` event. The [`ui.*` events](TODO-link-api-events-ui-section) contain various events relating to the component lifecycle.

```ts
@serializable
export default class ExampleComponentModel extends ComponentModelBase<
    ExampleComponentModelProperties
> {
    private readonly _handles: IHandle[] = [];

    protected async _onInitialize(): Promise<void> {
        super._onInitialize();
        // highlight-start
        this._handles.push(
            this.messages.events.ui.activated.subscribe(() => {
                // on activated logic here
            })
        );

        this._handles.push(
            this.messages.events.ui.deactivated.subscribe(() => {
                // on deactivated logic here
            })
        );
        // highlight-end
    }

    public destroy() {
        super.destroy();
        // highlight-start
        // Make sure to clean up subscriptions when the model is destroyed.
        this._handles.forEach((h) => h.remove());
        // highlight-end
    }
}
```
